# toptic

## zhihu

### CDN 是什么？使用 CDN 有什么优势？

1、内容分发网络（content delivery network）简称 CDN

2、优势

（1）CDN 的加速资源是跟域名绑定的。

（2）通过域名访问资源，首先是通过 DNS 分查找离用户最近的 CDN 节点（边缘服务器）的 IP

（3）通过 IP 访问实际资源时，如果 CDN 上并没有缓存资源，则会到源站请求资源，并缓存到 CDN 节点上，这样，用户下一次访问时，该 CDN 节点就会有对应资源的缓存了。

3、淘宝

对于淘宝，商品价格发生变化后，系统自动计算新的价格，自动合成图片，更新商品主图。

价格变化 ==》 图片更新。（特别双十一 0 点，价格都变成大促价格，更新频率非常高） ==》 导致：由于商品上的图片 url 变化，导致商品缓存失效，另一方面会大幅降低 CDN 的图片访问缓存命中率。

4、改图后

（1）CDN 及手机淘宝原本缓存的图片内容失效了，用户访问图片会全部回源到 img-picasso。

（2）由于更改了商品的字段，交易的核心应用（购物车和商品中心）的缓存也失效了，用户浏览及购物时，对商品的访问会走到 db。

5、应对

保持图片 url 不变、提前预热图片到 cdn

CDN 是将源站内容分发至最接近用户的节点，使用户可就近取得所需内容，提高用户访问的响应速度和成功率。解决因分布、带宽、服务器性能带来的访问延迟问题，适用于站点加速、点播、直播等场景。

CDN 的本质上是将媒体资源，动静态图片（Flash），HTML，CSS，JS 等等内容缓存到距离你更近的 IDC，从而让用户进行共享资源，实现缩减站点间的响应时间等等需求，而网游加速器的本质则是通过建立高带宽机房，架设多节点服务器来为用户进行加速。

作者：阿里云云栖号
链接：https://www.zhihu.com/question/36514327/answer/193768864
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

6、关于 CDN 的一些常见名词：

- 1、Origin Server 源站做 CDN 之前的客户真正的服务器。

- 2、User 访问者，也就是要访问网站的网民。

- 3、Last Mile 最后一公里，也就是网民到他所访问到的 CDN 服务器之间的路径。

- 4、域名域名是 Internet 网络上的一个服务器或一个网络系统的名字，全世界，没有重复的域名。

- 5、CNAME 记录它是一个别名记录( Canonical Name )；当 DNS 系统在查询 CNAME 左面的名称的时候，都会转向 CNAME 右面的名称再进行查询，一直追踪到最后的 PTR 或 A 名称，成功查询后才会做出回应，否则失败。

- 6、CNAME 域名 CDN 的域名加速需要用到 CNAME 记录，在阿里云控制台配置完成 CDN 加速后，您会得到一个加速后的域名，称之为 CNAME 域名（该域名一定是*.*http://kunlun.com）， 用户需要将自己的域名作 CNAME 指向这个*.*http://kunlun.com的域名后，域名解析的工作就正式转向阿里云，该域名所有的请求都将转向阿里云CDN的节点。

- 7、DNSDNS 即 Domain Name System，是域名解析服务的意思。它在互联网的作用是：把域名转换成为网络可以识别的 ip 地址。人们习惯记忆域名，但机器间互相只认 IP 地址，域名与 IP 地址之间是一一对应的，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。比如：上网时输入的百度一下，你就知道会自动转换成为 220.181.112.143

- 8、边缘节点也称 CDN 节点、Cache 节点等；是相对于网络的复杂结构而提出的一个概念，指距离最终用户接入具有较少的中间环节的网络节点，对最终接入用户有较好的响应能力和连接速度。其作用是将访问量较大的网页内容和对象保存在服务器前端的专用 cache 设备上，以此来提高网站访问的速度和质量。

- 9、cachecache 高速缓冲存储器一种特殊的存储器子系统，其中复制了频繁使用的数据以利于快速访问。存储器的高速缓冲存储器存储了频繁访问的 RAM 位置的内容及这些数据项的存储地址。当处理器引用存储器中的某地址时，高速缓冲存储器便检查是否存有该地址。如果存有该地址，则将数据返回处理器;如果没有保存该地址，则进行常规的存储器访问。因为高速缓冲存储器总是比主 RAM 存储器速度快，所以当 RAM 的访问速度低于微处理器的速度时，常使用高速缓冲存储器。

- [淘宝 CDN](https://www.zhihu.com/question/36514327?rf=37353035)

## juejin

## wechat

### 短链

#### 1、短链有啥好处，用长链不香吗？

- 链接变短，在对内容长度有限制的平台发文，可编辑的文字就变多了（如短信推广、微博限字）

- 需要将链接转成二维码的形式分享给他人，如果是长链的话二维码密集难识别。短链生成的码不密集，容易识别。

- 链接太长在有些平台上无法自动识别为超链接

#### 2、短链跳转的基本原理？

客户端访问短链 ==》 短链服务器返回（302 重定向）并且在 Response Headers 返回 location 指出长链地址 ==》 客户端访问长链对应服务器

- 301，代表 永久重定向，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301。

- 302，代表 临时重定向，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302！

#### 3、短链生成的几种方法？

- 观察可知：http://duanlian.com/1eio9e2tl 短链是由固定短链域名 + 长链映射成的一串字母组成。

- 一串字母 ==》 哈希函数解决 ==》 哈希函数的选取（不关心反向解密的难度，反而更关心的是哈希的运算速度和冲突概率）

- Google 出品的 MurmurHash 算法，非加密型哈希函数，适用于一般的哈希检索操作。与其它流行的哈希函数相比，对于规律性较强的 key，MurmurHash 的随机分布特征表现更良好。MurmurHash 提供了两种长度的哈希值，32 bit，128 bit。

- 转短链后为 http://gk.link/a/3002604296 觉得 3002604296 位数长，可将其转为 62 进制的数。

- 6 位 `62 进制`数可表示 568 亿的数

- [短链](https://mp.weixin.qq.com/s/jHUzr3y0cFD0REmT8SxAhA)

如 哈希值：nqw2、viwf、qs2a、usm7、yt20

- html2canvas 页面转图片

#### mdx 文档组件库

father 包管理 多个 package.json

docz 快速写文档的库 lerna monorepo 管理

Charles 抓包用，支持 https

### sm

#### vue 响应式数据的原理

1.核心点: Object.defineProperty

2.默认 Vue 在初始化数据时，会给 data 中的属性使用 Object.defineProperty 重新定义所有属
性,当页面取到对应属性时。会进行依赖收集（收集当前组件的 watcher） 如果属性发生变化会通
知相关依赖进行更新操作。

#### vue 如何检测数组变化

使用函数劫持的方式，重写了数组的方法

Vue 将 data 中的数组，进行了原型链重写。指向了自己定义的数组原型方法，这样当调用数组
api 时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控。

#### 为何 Vue 采用异步渲染 nextTick

因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染.所以为了性能考虑。 Vue
会在本轮数据更新后，再去异步更新视图!

#### nextTick 实现原理

理解:(宏任务和微任务) 异步方法

nextTick 方法主要是使用了宏任务和微任务,定义了一个异步方法.多次调用 nextTick 会将方法存入
队列中，通过这个异步方法清空当前队列。 所以这个 nextTick 方法就是异步方法

#### watch computer method 区别

默认 computed 也是一个 watcher 是具备缓存的，只要当依赖的属性发生变化时才会更新视图（lazy：true，默认不执行），计算属性算的是 data 没有的属性

watch

#### Watch 中的 deep:true 是如何实现的 递归

当用户指定了 watch 中的 deep 属性为 true 时，如果当前监控的值是数组类型。会对对象中的每
一项进行求值，此时会将当前 watcher 存入到对应属性的依赖中，这样数组中对象发生变化时也
会通知数据更新

#### vue

要掌握每个生命周期什么时候被调用
beforeCreate 在实例初始化之后，数据观测(data observer) 之前被调用。
created 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data
observer)，属性和方法的运算， watch/event 事件回调。这里没有$el
beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。
mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。
beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。
updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。
beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。
destroyed Vue 实例销毁后调用。调用后， Vue 实例指示的所有东西都会解绑定，所有的事件
监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。
要掌握每个生命周期内部可以做什么事
created 实例已经创建完成，因为它是最早触发的原因可以进行一些数据，资源的请求。
mounted 实例已经挂载完成，可以进行一些 DOM 操作
beforeUpdate 可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。
updated 可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，
因为这可能会导致更新无限循环。 该钩子在服务器端渲染期间不被调用。
destroyed 可以执行一些优化操作,清空定时器，解除绑定事件

### 请求接口放哪里

在 created 的时候，视图中的 dom 并没有渲染出来，所以此时如果直接去操 dom 节点，无法找到相
关的元素
在 mounted 中，由于此时 dom 已经渲染出来了，所以可以直接操作 dom 节点
一般情况下都放到 mounted 中,保证逻辑的统一性,因为生命周期是同步执行的， ajax 是异步执行的
服务端渲染不支持 mounted 方法，所以在服务端渲染的情况下统一放到 created 中

何时需要使用 beforeDestroy
理解:
可能在当前页面中使用了 \$on 方法，那需要在组件销毁前解绑。
清除自己定义的定时器
解除事件的绑定 scroll mousemove ....

### ast 语法树 VNode + data 【with 语法-js】

将 template 转化成 render 函数

```js
function baseCompile (
template: string,
options: CompilerOptions
) {
const ast = parse(template.trim(), options) // 1.将模板转化成ast语法树
if (options.optimize !== false) { // 2.优化树
optimize(ast, options)
}
const code = generate(ast, options) // 3.生成树
return {
ast,
render: code.render,
staticRenderFns: code.staticRenderFns
}
})
```

### diff 算法的时间复杂度

两个树的完全的 diff 算法是一个时间复杂度为 O(n3) , Vue 进行了优化·O(n3) 复杂度的问题转换成
O(n) 复杂度的问题(只比较同级不考虑跨级问题) 在前端当中， 你很少会跨越层级地移动 Dom 元素。 所
以 Virtual Dom 只会对同一个层级的元素进行对比。

template 转 ast 树 转 render 函数 转 \_create 转 虚拟 DOM

转 ast 语法树，vue 使用的一个库，这个库是 jquery 之父写的

### yuque

https://www.yuque.com/books/share/7a0bdadb-45f0-4dfd-b10d-ea21c5e84007?#

https://www.yuque.com/books/share/a0356a7e-9536-444f-8bfa-8d14f6866c79?#

https://www.yuque.com/books/share/58e34426-d05f-450e-99fb-15a4d9165710?#

https://www.yuque.com/books/share/a376071b-fee9-43e1-94e9-dc55d7bf45dd?#

https://www.yuque.com/books/share/dee1cbb3-3353-4c7c-940d-38d8f077113e?#
