(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{303:function(t,a,e){"use strict";e.r(a);var s=e(13),r=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"ast抽象语法树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ast抽象语法树"}},[t._v("#")]),t._v(" ast抽象语法树")]),t._v(" "),a("p",[t._v("抽象语法树（abstract syntax code，AST）是源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构，这所以说是抽象的，是因为抽象语法树并不会表示出真实语法出现的每一个细节，比如说，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。抽象语法树并不依赖于源语言的语法，也就是说语法分析阶段所采用的上下文无文文法，因为在写文法时，经常会对文法进行等价的转换（消除左递归，回溯，二义性等），这样会给文法分析引入一些多余的成分，对后续阶段造成不利影响，甚至会使合个阶段变得混乱。因些，很多编译器经常要独立地构造语法分析树，为前端，后端建立一个清晰的接口。")]),t._v(" "),a("p",[t._v("抽象语法树在很多领域有广泛的应用，比如浏览器，智能编辑器，编译器。")]),t._v(" "),a("h2",{attrs:{id:"什么是ast"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是ast"}},[t._v("#")]),t._v(" 什么是AST")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("在Vue的mount过程中，template会被编译成AST语法树，AST是指抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。")])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://github.com/zwStar/vue-ast",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue源码解析之Template转化为AST"),a("OutboundLink")],1)])])])])}),[],!1,null,null,null);a.default=r.exports}}]);