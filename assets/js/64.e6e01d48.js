(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{330:function(t,a,e){"use strict";e.r(a);var v=e(13),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"网络通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络通信"}},[t._v("#")]),t._v(" 网络通信")]),t._v(" "),a("h2",{attrs:{id:"http-https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-https"}},[t._v("#")]),t._v(" http https")]),t._v(" "),a("h3",{attrs:{id:"缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存"}},[t._v("#")]),t._v(" 缓存")]),t._v(" "),a("h4",{attrs:{id:"http-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[t._v("#")]),t._v(" http 缓存")]),t._v(" "),a("p",[t._v("浏览器 -----\x3e 网站")]),t._v(" "),a("p",[t._v("需要加载的资源：html、css、js、img。缓存起来减少网络请求的数量和体积")]),t._v(" "),a("h4",{attrs:{id:"强制缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),a("p",[t._v("第一次发送请求，服务器使用了强制缓存的话（觉得需要缓存），会在 response 响应头设置：设置 Cache-control 为： max-age：一个时间单位秒")]),t._v(" "),a("p",[t._v("浏览器会存在相应文件，下次再去请求时候，浏览器会检查 max-age 是否过期，没过期则直接拿。这时请求 code 是 200，Status Code 是 200（form memory cache）")]),t._v(" "),a("p",[t._v("基本原理：浏览器在加载资源的时候，会先根据本地缓存资源的 header 中的信息(Expires 和 Cache-Control)来判断是否需要强制缓存。如果命中的话，则会直接使用缓存中的资源。否则的话，会继续向服务器发送请求。")]),t._v(" "),a("p",[t._v("Expires 是 http1.0 的规范，它的值是一个绝对时间的 GMT 格式的时间字符串。这个时间代表的该资源的失效时间，如果在该时间之前请求的话，则都是从缓存里面读取的。但是使用该规范时，可能会有一个缺点就是当服务器的时间和客户端的时间不一样的情况下，会导致缓存失效。")]),t._v(" "),a("p",[t._v("Cache-Control 是 http1.1 的规范，它是利用该字段 max-age 值进行判断的。该值是一个相对时间，比如 Cache-Control: max-age=3600, 代表该资源的有效期是 3600 秒。除了该字段外，我们还有如下字段可以设置：")]),t._v(" "),a("p",[t._v("no-cache: 需要进行协商缓存，发送请求到服务器确认是否使用缓存。")]),t._v(" "),a("p",[t._v("no-store：禁止使用缓存，每一次都要重新请求数据。")]),t._v(" "),a("p",[t._v("public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。")]),t._v(" "),a("p",[t._v("private：只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。")]),t._v(" "),a("p",[t._v("Cache-Control 与 Expires 可以在服务端配置同时启用，同时启用的时候 Cache-Control 优先级高。")]),t._v(" "),a("h4",{attrs:{id:"协商缓存-对比缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存-对比缓存"}},[t._v("#")]),t._v(" 协商缓存（对比缓存）")]),t._v(" "),a("p",[t._v("服务端缓存策略：")]),t._v(" "),a("p",[t._v("第一次发送请求，服务器使用了协商缓存的话，会返回 【资源 和 标识】，浏览器存入。")]),t._v(" "),a("p",[t._v("下次请求，发送请求+资源标识，服务端把 资源标识 跟 自己的服务器上的对比，如果一致，返回 304 code，浏览器直接从缓存拿，如果不一致，返回 code 200，且新的资源、新的资源和新的标识。")]),t._v(" "),a("h4",{attrs:{id:"协商缓存的标识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存的标识"}},[t._v("#")]),t._v(" 协商缓存的标识")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("Last-Modified 资源上次修改时间")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第一次，返回的资源 + 资源标识（即 Last-Modified 在响应头）")])]),t._v(" "),a("li",[a("p",[t._v("Last-Modified 值是一个资源文件")])]),t._v(" "),a("li",[a("p",[t._v("再去请求时候，请求头带上 Last-Modified，但 key 叫：If-Modified-Since")])]),t._v(" "),a("li",[a("p",[t._v("服务器检查 If-Modified-Since，跟服务器自己对比，返回 304 or 200")])])])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("ETag 资源对应唯一字符串")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("第一次，返回的资源 + 资源标识（即 ETag）")])]),t._v(" "),a("li",[a("p",[t._v("ETag 值是一个 唯一字符串")])]),t._v(" "),a("li",[a("p",[t._v("再去请求时候，请求头带上 ETag，但 key 叫：If-None-Match")])]),t._v(" "),a("li",[a("p",[t._v("服务器检查 If-None-Match，跟服务器自己对比，返回 304 or 200")])])])])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("两个区别：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("优先使用 ETag")])]),t._v(" "),a("li",[a("p",[t._v("Last-Modified 只精确到秒级别")])]),t._v(" "),a("li",[a("p",[t._v("文件如果每隔一段时间都重复生成，但内容相同，Last-Modified 会每次返回资源文件，即便内容相同，但 ETag 可以判断出文件内容相同，返回 304 使用缓存。")])])])])]),t._v(" "),a("p",[t._v("memory cache: 它是将资源文件缓存到内存中。等下次请求访问的时候不需要重新下载资源，而是直接从内存中读取数据。")]),t._v(" "),a("p",[t._v("disk cache: 它是将资源文件缓存到硬盘中。等下次请求的时候它是直接从硬盘中读取。")]),t._v(" "),a("p",[t._v("memory cache(内存缓存)退出进程时数据会被清除，而 disk cache(硬盘缓存)退出进程时数据不会被清除。内存读取比硬盘中读取的速度更快。但是我们也不能把所有数据放在内存中缓存的，因为内存也是有限的。")]),t._v(" "),a("p",[t._v("memory cache(内存缓存)一般会将脚本、字体、图片会存储到内存缓存中。\ndisk cache(硬盘缓存) 一般非脚本会存放在硬盘中，比如 css 这些。")]),t._v(" "),a("p",[t._v("缓存读取的原理：先从内存中查找对应的缓存，如果内存中能找到就读取对应的缓存，否则的话就从硬盘中查找对应的缓存，如果有就读取，否则的话，就重新网络请求。")]),t._v(" "),a("h2",{attrs:{id:"websocket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[t._v("#")]),t._v(" websocket")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://juejin.cn/post/6844903489596833800",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP1.0、HTTP1.1 和 HTTP2.0 的区别"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=_.exports}}]);