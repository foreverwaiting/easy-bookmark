(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{318:function(n,t,e){"use strict";e.r(t);var o=e(13),l=Object(o.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"es6函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6函数"}},[n._v("#")]),n._v(" ES6函数")]),n._v(" "),t("p",[n._v("一.函数参数\n1.ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。(设置默认值直接写函数参数(括号)里面)\n（参数变量是默认声明的，所以不能用let或const再次声明。\n使用参数默认值时，函数不能有同名参数。\n参数默认值是惰性求值的。）\nfunction log(   x, y = 'World'    ) {\nconsole.log(x, y);\n}\nlog('Hello') // Hello World\n2.与解构赋值的默认值，结合起来使用。(使用解构赋值的默认值写在{括号}里面)\nfunction foo(   {x, y = 5}   ) {\nconsole.log(x, y);\n}\nfoo({}) // undefined 5\n使用了对象的解构赋值默认值，，只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。\n3.通过提供函数参数的默认值，就可以避免上述报错情况。(使用解构赋值的默认值提供给函数参数写在{括号}={}里面)\nfunction foo({x, y = 5} = {}) {\nconsole.log(x, y);\n}\nfoo() // undefined 5\n上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。\n4.解构赋值默认值的例子。\nfunction fetch(          url,        { body = '', method = 'GET', headers = {} }      ) {\nconsole.log(method);\n}\nfetch('http://example.com', {})\n// \"GET\"\nfetch('http://example.com')\n// 报错\n//更改\nfunction fetch(      url,        { body = '', method = 'GET', headers = {} }  =   {}     ) {\nconsole.log(method);\n}\nfetch('http://example.com')\n// \"GET\"\n5.写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；\nfunction m1({x = 0, y = 0} = {}) {\nreturn [x, y];\n}\n写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。\nfunction m2({x, y} = { x: 0, y: 0 }) {\nreturn [x, y];\n}\n6.参数位置\n通常情况下，定义了默认值的参数，应该是函数的尾参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\n7.参数length\n指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。rest 参数也不会计入length属性。\n8.参数作用域\n一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。\n函数的参数指向参数内变量时，外部同名变量不会影响到，如下：\nvar x = 1;\nfunction f(x, y = x) {\nconsole.log(y);\n}\nf(2) // 2\n但是当参数指向的变量不是参数内变量（未定义时），其会引用全局变量，如下：\nlet x = 1;\nfunction f(y = x) {\nlet x = 2;\nconsole.log(y);\n}\nf() // 1\n若此时全局变量不存在，则报错。\n并且：\nvar x = 1;\nfunction foo(x = x) {\n// ...\n}\nfoo() // ReferenceError: x is not defined")]),n._v(" "),t("p",[n._v('上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。\n如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。\n9.应用\n利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。另外，可以将参数默认值设为undefined，表明这个参数是可以省略的\n10.ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），函数的length属性，不包括 rest 参数。\n11.严格模式\n从 ES5 开始，函数内部可以设定为严格模式。\'use strict\';\nES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。\n12.函数名\n函数的name属性，返回该函数的函数名。\nES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。\n13.箭头函数\n1.ES6 允许使用“箭头”（=>）定义函数。\n箭头左边等同于：\n当无参数时：（）  等价于  function（）\nvar f = () => 5;\n// 等同于\nvar f = function () { return 5 };\n当有参数时：（a,b,v） 等价于   function（a,b,c）\nvar f = v => v;\n// 等同于\nvar f = function (v) {  return v; };\n箭头右边：\n当只有一条语句时：  num1+num2    等价于    return   num1+num2\n当多条语句时： 使用大括号{}包住，并且使用return语句返回\nvar sum = (num1, num2) => num1 + num2;\n// 等同于\nvar sum = function(num1, num2) {  return num1 + num2;};\n由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。\n// 报错\nlet getTempItem = id => { id: id, name: "Temp" };\n// 不报错\nlet getTempItem = id => ({ id: id, name: "Temp" });\n2.箭头函数可以与变量解构结合使用。\n箭头函数的一个用处是简化回调函数。')]),n._v(" "),t("p",[n._v("箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。\n箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。\n3.由于箭头函数使得this从“动态”变成“静态”，下面两个场合不应该使用箭头函数。\n第一个场合是定义对象的方法，且该方法内部包括this。\n第二个场合是需要动态this的时候，也不应使用箭头函数。\n4.尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。\n我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。\n“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。（只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。）\n5.尾递归\n函数调用自身，称为递归。如果尾调用自身，就称为尾递归。\n递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。\n一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。\n如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。\n“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。\n尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。\n函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式.(采用 ES6 的函数默认值)\n总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。\n6.函数参数的尾逗号\nES2017 允许函数的最后一个参数有尾逗号（trailing comma）。\n此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。")])])}),[],!1,null,null,null);t.default=l.exports}}]);